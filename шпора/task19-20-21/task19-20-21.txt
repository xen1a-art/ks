Округление:
В большую сторону:
    from math import ceil (ЛУЧШЕ ТАК)
    ceil(num / 2)
В меньшую сторону:
    num // 2
Математическое округление:
    round(num / 2)

==============================================================

Условия проверки на победу (в основном применимо к заданиям 19):
1. Известно, что Ваня выиграл своим первым ходом после неудачного хода Пети
Если противник неудачник, то нам не важно как он походит.
Главное, что он совершит неудачный ход и приведет нас к победе. В коде в последней строке функции пишем
  return any(h)

2. Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом
Мы должны победить при любом ходе противника.
Т.е. он выстраивает стратегию и не будет совершать ходы, которые приведут его к проигрышу.
В коде в последней строке функции пишем
  return any(h) if (s-1) % 2 == 0 else all(h)

=====================================================================================

Условия завершения игры:
1. Петя победил первым ходом
  print([s for s in range(1, 69) if f(s, 1)])
2. Ваня победил первым ходом
  print([s for s in range(1, 69) if f(s, 2)])
3. Петя победи вторым или первым ходом, но не только первым
  print([s for s in range(1, 69) if f(s, 3) and not f(s, 1)])
4. Ваня победил вторым или первым  ходом, но не только первым
  print([s for s in range(1, 69) if f(s, 4) and not f(s, 2)])
5. Петя победил третьим, вторым или первым  ходом, но не только первым или только вторым
  print([s for s in range(1, 69) if f(s, 5) and not f(s, 3)])
6. Ваня победил третьим, вторым или первым  ходом, но не только первым или только вторым
  print([s for s in range(1, 69) if f(s, 6) and not f(s, 4)])

=======================================================================================

Общий алгоритм кодом:
def f(x, s): # x - кол-во камней, s - кол-во ходов до конца игры
   if x <= 12: # условие завершения игры
       return s % 2 == 0 # возвращаем того, кто сделал последний ход
   if s == 0: # если ходы кончились, игра завершается с проигрышем
       return False
   h = [f(x // 3, s - 1), f(x - 12, s - 1)] # список всех возможных действий
   return any(h) if (s - 1) % 2 == 0 else all(h)
# Ответ для каждого задания
print('19) ', [s for s in range(1000, 13, -1) if f(s, 2)])
print('20) ', [s for s in range(1000, 13, -1) if f(s, 3) and not f(s, 1)])
print('21) ', [s for s in range(1000, 13, -1) if f(s, 4) and not f(s, 2)])

=======================================================================================
Пример 1 (одна куча + любой ход):
Перед игроками лежит куча камней. За один ход игрок может добавить в кучу один или три камня либо увеличить количество камней в куче в четыре раза.
Игра завершается в тот момент, когда количество камней в куче становится не менее 111.
Победителем считается игрок, сделавший последний ход, т.е. первым получивший кучу, состоящую из 111 или более камней.
В начальный момент в куче было S камней; 1 ≤ S ≤ 110.
Задание 19.
Укажите такое значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.
Задание 20.
Для игры, описанной в задании 19, найдите два таких минимальных значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Задание 21.
Для игры, описанной в задании 19, найдите минимальное значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
Если найдено несколько значений S, в ответе запишите наименьшее из них.
Решение:
  def f(x, s):
     if x >= 111: return s % 2 == 0
     if s == 0: return False
     h = [f(x + 1, s - 1), f(x + 3, s - 1), f(x * 4, s - 1)]
     return any(h) if (s - 1) % 2 == 0 else all(h)
  print('19)', [s for s in range(1, 111) if f(s,  2)])
  print('20)', [s for s in range(1, 111) if f(s,  3) and not f(s, 1)])
  print('21)', [s for s in range(1, 111) if f(s,  4) and not f(s, 2)])


=======================================================================================

Пример 2 (одна куча + неудачный ход):
Перед игроками лежит куча камней. За один ход игрок может увеличить количество камней в два раза или в три раза.
Игра завершается в тот момент, когда количество камней в куче становится не менее 100.
Победителем считается игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой в куче будет 100 или больше камней.
В начальный момент в куче S камней; 1 ≤ S ≤ 99.
Задание 19.
Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Укажите минимальное значение S, когда такая ситуация возможна.
Задание 20.
Для игры, описанной в предыдущем задании, найдите все значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
В ответе запишите сначала минимальное, затем максимальное найденные значения.
Задание 21.
Для игры, описанной в задании 19, найдите минимальное значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
Решение:
  def f_19(x, s):
     if x >= 100: return s % 2 == 0
     if s == 0: return False
     h = [f_19(x * 2, s - 1), f_19(x * 3, s - 1)]
     return any(h)
  def f(x, s):
     if x >= 100: return s % 2 == 0
     if s == 0: return False
     h = [f(x * 2, s - 1), f(x * 3, s - 1)]
     return any(h) if (s - 1) % 2 == 0 else all(h)
  print('19)', [s for s in range(1, 100) if f_19(s,  2)])
  print('20)', [s for s in range(1, 100) if f(s,  3) and not f(s, 1)])
  print('21)', [s for s in range(1, 100) if f(s,  4) and not f(s, 2)])

=======================================================================================

Пример 3 (две кучи + любой ход):
Перед игроками лежит две кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч (по своему выбору) один камень, или увеличить количество камней в куче в два раза.
Игра завершается в тот момент, когда произведение количеств камней в кучах становится не менее 63. Победителем считается игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой произведение числа камней в кучах будет 63 или более.
В начальный момент в первой куче было 2 камня, во второй куче - S камней; 1 ≤ S ≤ 31.
Задание 19.
Найдите значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом?
Задание 20.
Для игры, описанной в предыдущем задании, найдите минимальное и максимальное значение S, при котором у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
- Петя не может выиграть за один ход;
- Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Задание 21.
 Для игры, описанной в задании 19, найдите наибольшее значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
Решение:
  def f(x, y, s):
     if x * y >= 63: return s % 2 == 0
     if s == 0: return False
     h = [f(x+1, y, s-1), f(x*2, y, s-1), f(x, y+1, s-1), f(x, y*2, s-1)]
     return any(h) if (s - 1) % 2 == 0 else all(h)
  print('19)', [s for s in range(1,32) if f(s, 2, 2)])
  print('20)', [s for s in range(1,32) if f(s, 2, 3) and not f(s, 2, 1)])
  print('21)', [s for s in range(1,32) if f(s, 2, 4) and not f(s, 2, 2)])



=======================================================================================

Пример 4 (две кучи + неудачный ход):
Перед игроками лежит две кучи камней. За один ход игрок может добавить в одну из куч один камень либо увеличить количество камней в куче в два раза.
Игра завершается в тот момент, когда суммарное количество камней в кучах становится не менее 123.
Победителем считается игрок, сделавший последний ход, т.е. первым получивший суммарно в кучах 123 или больше камней.
В начальный момент в первой куче было 13 камней, во второй – S камней; 1 ≤ S ≤ 109.
Задание 19.
Известно, что Ваня выиграл своим первым ходом после неудачного хода Пети.
Укажите минимальное значение S, когда такая ситуация возможна.
Задание 20.
Для игры, описанной в задании 19, найдите два таких минимальных значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Задание 21.
Для игры, описанной в задании 19, найдите минимальное значение S, при котором одновременно выполняются два условия:
–    у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
–    у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом. Если найдено несколько значений S, в ответе запишите наименьшее из них.
Решение:
  def f_19(x, y, s):
     if x + y >= 123: return s % 2 == 0
     if s == 0: return False
    h = [f_19(x+1, y, s-1), f_19(x*2, y, s-1), \
         f_19(x, y+1, s-1), f_19(x, y*2, s-1)]
     return any(h)
  def f(x, y, s):
     if x + y >= 123: return s % 2 == 0
     if s == 0: return False
     h = [f(x+1, y, s-1), f(x*2, y, s-1), f(x, y+1, s-1), f(x, y*2, s-1)]
     return any(h) if (s - 1) % 2 == 0 else all(h)
  print('19)', [s for s in range(1, 110) if f_19(s, 13, 2)])
  print('20)', [s for s in range(1, 110) if f(s,13,3) and not f(s,13,1)])
  print('21)', [s for s in range(1, 110) if f(s,13,4) and not f(s,13,2)])